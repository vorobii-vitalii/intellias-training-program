<!DOCTYPE html>
<html lang="en-US">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Editor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tinymce/6.4.1/tinymce.min.js"></script>
<!--    <script src="https://cdnjs.cloudflare.com/ajax/libs/diff-match-patch/1.0.5/index.min.js"></script>-->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js"></script>
</head>

<body>

<h1>Text editor</h1>
<div id="event-container"></div>

<textarea id="editor" cols="150" rows="80">

</textarea>

</body>

<script>

    const socket = new WebSocket("wss://localhost/documents");

    let connectionId;
    let arr;

    // private int compareAt(int pos, TreeDocPath<D> leftPath, TreeDocPath<D> rightPath) {
    //     boolean lPos = leftPath.isSet(pos);
    //     boolean rPos = rightPath.isSet(pos);
    //     D lDisambiguator = leftPath.disambiguatorAt(pos);
    //     D rDisambiguator = rightPath.disambiguatorAt(pos);
    //     if (lDisambiguator == null && rDisambiguator == null) {
    //         if (lPos != rPos) {
    //             return lPos ? 1 : -1;
    //         } else {
    //             return 0;
    //         }
    //     } else if (lDisambiguator != null && rDisambiguator != null) {
    //         if (lPos != rPos) {
    //             return lPos ? 1 : -1;
    //         } else {
    //             return lDisambiguator.compareTo(rDisambiguator);
    //         }
    //     } else if (lDisambiguator != null) {
    //         return rPos ? -1 : 1;
    //     } else {
    //         return lPos ? 1 : -1;
    //     }
    // }

    const comparePath = (a, b) => {
        const m = Math.min(a.length, b.length);
        // console.log("Comparing path  of " + JSON.stringify(a) + " and " + JSON.stringify(b) + " min = " + m);
        for (let i = 0; i < m; i++) {
            if (a[i].second && b[i].second) {
                if (a[i].first !== b[i].first) {
                    return a[i].first ? 1 : -1;
                }
                if (a[i].second !== b[i].second) {
                    return a[i].second < b[i].second ? -1 : 1;
                }
            }
            else if (!a[i].second && !b[i].second) {
                if (a[i].first !== b[i].first) {
                    return a[i].first ? 1 : -1;
                }
            }
            else if (a[i].second) {
                return b[i].first ? -1 : 1;
            }
            else {
                return a[i].first ? 1 : -1;
            }
        }
        if (a.length === b.length) {
            return 0;
        }
        if (a.length === m) {
            return b[m].first ? -1 : 1;
        }
        return a[m].first ? 1 : -1;
    };
    const textArea = document.getElementById("editor");

    socket.onmessage = function(event) {
        const eventPayload = JSON.parse(event.data);
        // console.log('Websocket event');
        // console.log(eventPayload);
        // console.log(arr);

        if (eventPayload.responseType === 'ON_CONNECT') {
            // console.log('Setting value');
            // console.log(eventPayload.payload.currentState.map(v => v.second))
            arr = eventPayload.payload.currentState;
            connectionId = eventPayload.payload.connectionId;
        }
        else if (eventPayload.responseType === 'ADD') {
            // console.log('ADD Event');
            arr.splice(arr.length, 0, eventPayload.payload);
            arr = arr.sort((a, b) => {
                return comparePath(a.first, b.first);
            });
        }
        else if (eventPayload.responseType === 'DELETE') {
            // console.log('DELETE Event');
            arr = arr.filter(a => {
                let c = comparePath(a.first, eventPayload.payload);
                return c !== 0;
            });
        }
        document.getElementById("editor").value = arr.map(v => v.second).join('');
    };
    socket.onopen = () => {
        socket.send(JSON.stringify({
            type: 'CONNECT'
        }));
    };

    const createPair = (left, right, c) => {
        if (!left && !right) {
            return {first: [{first: false, second: connectionId}], second: c};
        }
        if (!left) {
            return {first: [...right.first, {first: false, second: connectionId}], second: c};
        }
        else if (!right) {
            return {first: [...left.first, {first: true, second: connectionId}], second: c};
        }
        if (isAncestor(left.first, right.first)) {
            return {first: [...right.first, {first: false, second: connectionId}], second: c};
        }
        return {first: [...left.first, {first: true, second: connectionId}], second: c};
    };

    const isAncestor = (a, b) => {
        if (b.length < a.length) {
            return false;
        }
        for (let i = 0; i < a.length; i++) {
            if (a[i].first !== b[i].first || a[i].second !== b[i].second) {
                return false;
            }
        }
        return true;
    };

    const extract = index => {
        if (index < 0 || index >= arr.length) {
            return null;
        }
        return arr[index];
    };

    const dmp = new diff_match_patch();

    textArea.addEventListener("change", event => {
        console.log("Change");
        console.log(event);
        const curr = arr.map(v => v.second).join('');
        const updated = textArea.value;
        const diff = dmp.diff_main(curr, updated);
        let prevIndex = -1;
        let newArr = [];
        for (const component of diff) {
            const v = component[0];
            const str = component[1];
            if (v === 0) {
                for (let i = 0; i < str.length; i++) {
                    newArr.splice(newArr.length, 0, arr[i + prevIndex + 1]);
                }
                prevIndex += str.length;
            }
            else if (v === -1) {
                for (let i = 0; i < str.length; i++) {
                    socket.send(JSON.stringify({
                        type: 'DELETE',
                        payload: arr[i + prevIndex + 1].first
                    }));
                }
                prevIndex += str.length;
            }
            else {
                let prev = extract(prevIndex);
                const next = extract(prevIndex + 1);
                for (let i = 0; i < str.length; i++) {
                    const c = str.charAt(i);
                    let a = createPair(prev, next, c)

                    // while (
                    //     arr.filter(v => {
                    //         let c = comparePath(a.first, v.first);
                    //         return c === 0;
                    //     }).length > 0
                    // ) {
                    //     a = {first: [...a.first, {first: false, second: connectionId}], second: c}
                    // }
                    console.log('New ' + JSON.stringify(a) + " Prev " + JSON.stringify(prev) + " Next = " + JSON.stringify(next));
                    socket.send(JSON.stringify({
                        type: 'ADD',
                        payload: a
                    }));
                    newArr.splice(newArr.length, 0, a);
                    prev = a;
                }
            }
        }
        arr = newArr;
        // console.log(curr);
        // console.log(updated);
        // console.log(diff);
    });

</script>

</html>