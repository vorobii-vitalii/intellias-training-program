<!DOCTYPE html>
<html lang="en-US">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Editor</title>
    <!--[if lte IE 9]>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.1.10/es5-shim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/json3/3.3.2/json3.min.js"></script>
    <![endif]-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/msgpack-lite/0.1.26/msgpack.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js"></script>
</head>

<body>

<h1>Text editor</h1>

<textarea id="editor" rows="40" cols="140">
</textarea>

</body>

<script>

    const comparePath = (a, b) => {
        const m = Math.min(a.length, b.length);
        for (let i = 0; i < m; i++) {
            if (a[i].disambiguator && b[i].disambiguator) {
                if (a[i].isLeft !== b[i].isLeft) {
                    return a[i].isLeft ? 1 : -1;
                }
                if (a[i].disambiguator !== b[i].disambiguator) {
                    return a[i].disambiguator < b[i].disambiguator ? -1 : 1;
                }
            } else if (!a[i].disambiguator && !b[i].disambiguator) {
                if (a[i].isLeft !== b[i].isLeft) {
                    return a[i].isLeft ? 1 : -1;
                }
            } else if (a[i].disambiguator) {
                return b[i].isLeft ? -1 : 1;
            } else {
                return a[i].isLeft ? 1 : -1;
            }
        }
        if (a.length === b.length) {
            return 0;
        }
        if (a.length === m) {
            return b[m].isLeft ? -1 : 1;
        }
        return a[m].isLeft ? 1 : -1;
    };

    const createPair = (left, right, c) => {
        if (!left && !right) {
            return {treePath: [{isLeft: false, disambiguator: connectionId}], character: c};
        }
        if (!left) {
            return {treePath: [...right.treePath, {isLeft: false, disambiguator: connectionId}], character: c};
        } else if (!right) {
            return {treePath: [...left.treePath, {isLeft: true, disambiguator: connectionId}], character: c};
        }
        if (isAncestor(left.treePath, right.treePath)) {
            return {treePath: [...right.treePath, {isLeft: false, disambiguator: connectionId}], character: c};
        }
        return {treePath: [...left.treePath, {isLeft: true, disambiguator: connectionId}], character: c};
    };

    const isAncestor = (a, b) => {
        if (b.length < a.length) {
            return false;
        }
        for (let i = 0; i < a.length; i++) {
            if (a[i].isLeft !== b[i].isLeft || a[i].disambiguator !== b[i].disambiguator) {
                return false;
            }
        }
        return true;
    };

    const extract = index => {
        if (index < 0 || index >= arr.length) {
            return null;
        }
        return arr[index];
    };

    let changes = [];
    const dmp = new diff_match_patch();
    let socket;

    let connectionId;
    let arr = [];

    const textArea = document.getElementById("editor");

    const binarySearch = (path) => {
        let low = 0;
        let high = arr.length - 1;
        let res = -1;
        while (low <= high) {
            const mid = Math.floor((low + high) / 2);
            const c = comparePath(path, arr[mid].treePath);
            if (c === 0) {
                return mid;
            }
            if (c > 0) {
                res = mid;
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return res;
    };

    socket = new WebSocket("ws://localhost:8001/documents");
    socket.binaryType = "arraybuffer";
    socket.onmessage = function (event) {
        const eventPayload = msgpack.decode(new Uint8Array(event.data));

        if (eventPayload.responseType === 'ON_CONNECT') {
            connectionId = eventPayload.payload.connectionId;
        }
        else if (eventPayload.responseType === 'ADD_BULK') {
            for (const change of eventPayload.payload) {
                const index = binarySearch(change.treePath);
                if (index < 0 || index >= arr.length || comparePath(arr[index].treePath, change.treePath) !== 0) {
                    arr.splice(index + 1, 0, change);
                }
            }

        }
        else if (eventPayload.responseType === 'CHANGES') {
            for (const change of eventPayload.payload) {
                const index = binarySearch(change.treePath);
                if (!change.character) {
                    if (index >= 0 && index < arr.length && comparePath(arr[index].treePath, change.treePath) === 0) {
                        arr.splice(index, 1);
                    }
                } else {
                    if (index < 0 || index >= arr.length || comparePath(arr[index].treePath, change.treePath) !== 0) {
                        arr.splice(index + 1, 0, change);
                    }
                }
            }
        }
        textArea.value = arr.map(v => v.character).join('');
    };
    socket.onopen = () => {
        socket.send(msgpack.encode({
            type: 'CONNECT'
        }));
    };
    const batchSize = 100;

    setInterval(() => {
        if (changes.length > 0) {
            // console.log('Sending changes');
            // console.log(changes);
            socket.send(msgpack.encode({
                type: 'CHANGES',
                payload: changes.slice(0, batchSize)
            }));
            changes = changes.slice(batchSize, changes.length);
        }
    }, 25);


    textArea.addEventListener("change", event => {
        const curr = arr.map(v => v.character).join('');
        const updated = textArea.value;
        const diff = dmp.diff_main(curr, updated);
        let prevIndex = -1;
        let newArr = [];
        for (const component of diff) {
            const v = component[0];
            const str = component[1];
            if (v === 0) {
                for (let i = 0; i < str.length; i++) {
                    newArr.splice(newArr.length, 0, arr[i + prevIndex + 1]);
                }
                prevIndex += str.length;
            } else if (v === -1) {
                for (let i = 0; i < str.length; i++) {
                    changes.splice(changes.length, 0, {
                        treePath: arr[i + prevIndex + 1].treePath
                    });
                }
                prevIndex += str.length;
            } else {
                let prev = extract(prevIndex);
                const next = extract(prevIndex + 1);
                for (let i = 0; i < str.length; i++) {
                    const c = str.charAt(i);
                    let a = createPair(prev, next, c)
                    changes.splice(changes.length, 0, a);
                    newArr.splice(newArr.length, 0, a);
                    prev = a;
                }
            }
        }
        arr = newArr;
    });



</script>

</html>