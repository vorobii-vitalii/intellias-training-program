<!DOCTYPE html>
<html lang="en-US">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Editor</title>
    <!--[if lte IE 9]>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.1.10/es5-shim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/json3/3.3.2/json3.min.js"></script>
    <![endif]-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/msgpack-lite/0.1.26/msgpack.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>
</head>

<body>

<h1>Text editor</h1>

<textarea id="editor" rows="40" cols="140">
</textarea>

</body>

<script>
  const comparePath = (a, b) => {
    const aLength = a.directions.length;
    const bLength = b.directions.length;
    const m = Math.min(aLength, bLength);
    for (let i = 0; i < m; i++) {
      if (a.directions[i] !== b.directions[i]) {
        return a.directions[i] ? 1 : -1;
      }
      if (a.disambiguators[i]  !== b.disambiguators[i] ) {
        return a.disambiguators[i] < b.disambiguators[i] ? -1 : 1;
      }
    }
    if (aLength === bLength) {
      return 0;
    }
    if (aLength === m) {
      return b.disambiguators[m] ? -1 : 1;
    }
    return a.disambiguators[m] ? 1 : -1;
  };

  const createPair = (left, right, c) => {
    if (!left && !right) {
      return {
        treePath: {
          directions: [false],
          disambiguators: [connectionId]
        },
        character: c
      };
    }
    if (!left) {
      return {
        treePath: {
          directions: [...right.treePath.directions, false],
          disambiguators: [...right.treePath.disambiguators, connectionId]
        },
        character: c
      };
    } else if (!right) {
      return {
        treePath: {
          directions: [...left.treePath.directions, true],
          disambiguators: [...left.treePath.disambiguators, connectionId]
        },
        character: c
      };
    }
    if (isAncestor(left.treePath, right.treePath)) {
      return {
        treePath: {
          directions: [...right.treePath.directions, false],
          disambiguators: [...right.treePath.disambiguators, connectionId]
        },
        character: c
      };
    }
    return {
      treePath: {
        directions: [...left.treePath.directions, true],
        disambiguators: [...left.treePath.disambiguators, connectionId]
      },
      character: c
    };
  };

  const isAncestor = (a, b) => {
    const aLength = a.directions.length;
    const bLength = b.directions.length;
    if (bLength < aLength) {
      return false;
    }
    for (let i = 0; i < aLength; i++) {
      if (a.directions[i] !== b.directions[i] || a.disambiguators[i] !== b.disambiguators[i]) {
        return false;
      }
    }
    return true;
  };

  const extract = index => {
    if (index < 0 || index >= arr.length) {
      return null;
    }
    return arr[index];
  };

  let changes = [];
  const dmp = new diff_match_patch();
  let socket;

  let connectionId;
  let arr = [];

  const textArea = document.getElementById("editor");

  const binarySearch = (path) => {
    let low = 0;
    let high = arr.length - 1;
    let res = -1;
    while (low <= high) {
      const mid = Math.floor((low + high) / 2);
      const c = comparePath(path, arr[mid].treePath);
      if (c === 0) {
        return mid;
      }
      if (c > 0) {
        res = mid;
        low = mid + 1;
      } else {
        high = mid - 1;
      }
    }
    return res;
  };

  let lastPong = new Date();

  socket = new WebSocket("ws://localhost:8001/documents");
  socket.binaryType = "arraybuffer";
  socket.onmessage = function(event) {
    const data = pako.ungzip(event.data)
    const eventPayload = msgpack.decode(new Uint8Array(data));

    if (eventPayload.responseType === 'ON_CONNECT') {
      connectionId = eventPayload.payload.connectionId;
    } else if (eventPayload.responseType === 'ADD_BULK') {
      for (const change of eventPayload.payload) {
        const index = binarySearch(change.treePath);
        if (index < 0 || index >= arr.length || comparePath(arr[index].treePath, change.treePath) !== 0) {
          arr.splice(index + 1, 0, change);
        }
      }

    } else if (eventPayload.responseType === 'CHANGES') {
      for (const change of eventPayload.payload) {
        const index = binarySearch(change.treePath);
        if (!change.character) {
          if (index >= 0 && index < arr.length && comparePath(arr[index].treePath, change.treePath) === 0) {
            arr.splice(index, 1);
          }
        } else {
          if (index < 0 || index >= arr.length || comparePath(arr[index].treePath, change.treePath) !== 0) {
            arr.splice(index + 1, 0, change);
          }
        }
      }
    } else if (eventPayload.responseType === 'PONG') {
      lastPong = new Date();
    }
    textArea.value = arr.map(v => v.character).join('');
  };
  socket.onopen = () => {
    socket.send(msgpack.encode({
      type: 'CONNECT'
    }));
    setInterval(() => {
      socket.send(msgpack.encode({
        type: 'PING',
      }));
    }, 2000);
  };
  const batchSize = 100;

  setInterval(() => {
    if (changes.length > 0) {
      // console.log('Sending changes');
      // console.log(changes);
      socket.send(msgpack.encode({
        type: 'CHANGES',
        payload: changes.slice(0, batchSize)
      }));
      changes = changes.slice(batchSize, changes.length);
    }
  }, 25);

  setInterval(() => {
    const d = new Date().getTime() - lastPong.getTime();
    console.log('Ms since last PONG ', d);
    if (d >= 5000) {
      console.log("Disconnected");
    }
  }, 2000);

  textArea.addEventListener("change", event => {
    const curr = arr.map(v => v.character).join('');
    const updated = textArea.value;
    const diff = dmp.diff_main(curr, updated);
    let prevIndex = -1;
    let newArr = [];
    for (const component of diff) {
      const v = component[0];
      const str = component[1];
      if (v === 0) {
        for (let i = 0; i < str.length; i++) {
          newArr.splice(newArr.length, 0, arr[i + prevIndex + 1]);
        }
        prevIndex += str.length;
      } else if (v === -1) {
        for (let i = 0; i < str.length; i++) {
          changes.splice(changes.length, 0, {
            treePath: arr[i + prevIndex + 1].treePath
          });
        }
        prevIndex += str.length;
      } else {
        let prev = extract(prevIndex);
        const next = extract(prevIndex + 1);
        for (let i = 0; i < str.length; i++) {
          const c = str.charAt(i);
          let a = createPair(prev, next, c);
          changes.splice(changes.length, 0, a);
          newArr.splice(newArr.length, 0, a);
          prev = a;
        }
      }
    }
    arr = newArr;
  });


</script>

</html>