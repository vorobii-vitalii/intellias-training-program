<!DOCTYPE html>
<html lang="en-US">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Editor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tinymce/6.4.1/tinymce.min.js"></script>
    <!--[if lte IE 9]>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.1.10/es5-shim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/json3/3.3.2/json3.min.js"></script>
    <![endif]-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/msgpack-lite/0.1.26/msgpack.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js"></script>
</head>

<body>

<h1>Text editor</h1>

<textarea id="editor">
</textarea>

</body>

<script>

    const comparePath = (a, b) => {
        const m = Math.min(a.length, b.length);
        for (let i = 0; i < m; i++) {
            if (a[i].b && b[i].b) {
                if (a[i].a !== b[i].a) {
                    return a[i].a ? 1 : -1;
                }
                if (a[i].b !== b[i].b) {
                    return a[i].b < b[i].b ? -1 : 1;
                }
            } else if (!a[i].b && !b[i].b) {
                if (a[i].a !== b[i].a) {
                    return a[i].a ? 1 : -1;
                }
            } else if (a[i].b) {
                return b[i].a ? -1 : 1;
            } else {
                return a[i].a ? 1 : -1;
            }
        }
        if (a.length === b.length) {
            return 0;
        }
        if (a.length === m) {
            return b[m].a ? -1 : 1;
        }
        return a[m].a ? 1 : -1;
    };

    const createPair = (left, right, c) => {
        if (!left && !right) {
            return {a: [{a: false, b: connectionId}], b: c};
        }
        if (!left) {
            return {a: [...right.a, {a: false, b: connectionId}], b: c};
        } else if (!right) {
            return {a: [...left.a, {a: true, b: connectionId}], b: c};
        }
        if (isAncestor(left.a, right.a)) {
            return {a: [...right.a, {a: false, b: connectionId}], b: c};
        }
        return {a: [...left.a, {a: true, b: connectionId}], b: c};
    };

    const isAncestor = (a, b) => {
        if (b.length < a.length) {
            return false;
        }
        for (let i = 0; i < a.length; i++) {
            if (a[i].a !== b[i].a || a[i].b !== b[i].b) {
                return false;
            }
        }
        return true;
    };

    const extract = index => {
        if (index < 0 || index >= arr.length) {
            return null;
        }
        return arr[index];
    };

    let changes = [];
    const dmp = new diff_match_patch();
    let socket;

    let connectionId;
    let arr = [];

    const textArea = document.getElementById("editor");

    const onDocumentChange = instance => {
        const updated = tinymce.get("editor").getContent();
        const curr = arr.map(v => v.b).join('');
        const diff = dmp.diff_main(curr, updated);
        let prevIndex = -1;
        let newArr = [];
        for (const component of diff) {
            const v = component[0];
            const str = component[1];
            if (v === 0) {
                for (let i = 0; i < str.length; i++) {
                    newArr.splice(newArr.length, 0, arr[i + prevIndex + 1]);
                }
                prevIndex += str.length;
            } else if (v === -1) {
                for (let i = 0; i < str.length; i++) {
                    changes.splice(changes.length, 0, {
                        a: arr[i + prevIndex + 1].a
                    });
                }
                prevIndex += str.length;
            } else {
                let prev = extract(prevIndex);
                const next = extract(prevIndex + 1);
                for (let i = 0; i < str.length; i++) {
                    const c = str.charAt(i);
                    let a = createPair(prev, next, c)
                    changes.splice(changes.length, 0, a);
                    newArr.splice(newArr.length, 0, a);
                    prev = a;
                }
            }
        }
        arr = newArr;
    };

    tinyMCE.init({
        selector: 'textarea#editor',
        mode : "textareas",
        setup: function (instance) {
            instance.on("change", function () {
                onDocumentChange(instance);
                tinyMCE.triggerSave();
            });
            instance.on('init', function(e) {
                console.log('The Editor has initialized.');
                socket = new WebSocket("ws://localhost:8001/documents");
                socket.binaryType = "arraybuffer";
                socket.onmessage = function (event) {
                    const eventPayload = msgpack.decode(new Uint8Array(event.data));

                    if (eventPayload.responseType === 'ON_CONNECT') {
                        connectionId = eventPayload.payload.connectionId;
                    } else if (eventPayload.responseType === 'ADD') {
                        // Binary search
                        arr = arr.filter(a => {
                            let c = comparePath(a.a, eventPayload.payload.a);
                            return c !== 0;
                        });
                        arr.splice(arr.length, 0, eventPayload.payload);
                        arr = arr.sort((a, b) => {
                            return comparePath(a.a, b.a);
                        });
                    } else if (eventPayload.responseType === 'ADD_BULK') {
                        for (const change of eventPayload.payload) {
                            // Binary search
                            arr = arr.filter(a => {
                                let c = comparePath(a.a, change.a);
                                return c !== 0;
                            });
                            arr.splice(arr.length, 0, change);
                            arr = arr.sort((a, b) => {
                                return comparePath(a.a, b.a);
                            });
                        }

                    } else if (eventPayload.responseType === 'DELETE') {
                        // console.log('DELETE Event');
                        arr = arr.filter(a => {
                            let c = comparePath(a.a, eventPayload.payload);
                            return c !== 0;
                        });
                    } else if (eventPayload.responseType === 'CHANGES') {
                        for (const change of eventPayload.payload) {
                            if (!change.b) {
                                arr = arr.filter(a => {
                                    let c = comparePath(a.a, change.a);
                                    return c !== 0;
                                });
                            } else {
                                // Binary search
                                arr = arr.filter(a => {
                                    let c = comparePath(a.a, change.a);
                                    return c !== 0;
                                });
                                arr.splice(arr.length, 0, change);
                                arr = arr.sort((a, b) => {
                                    return comparePath(a.a, b.a);
                                });
                            }
                        }
                    }
                    tinymce.get("editor").setContent(arr.map(v => v.b).join(''));

                    // textArea.value = arr.map(v => v.b).join('');
                };
                socket.onopen = () => {
                    socket.send(msgpack.encode({
                        type: 'CONNECT'
                    }));
                };
                const batchSize = 100;

                setInterval(() => {
                    if (changes.length > 0) {
                        // console.log('Sending changes');
                        // console.log(changes);
                        socket.send(msgpack.encode({
                            type: 'CHANGES',
                            payload: changes.slice(0, batchSize)
                        }));
                        changes = changes.slice(batchSize, changes.length);
                    }
                }, 25);
            });
        }
    });







    // textArea.addEventListener("change", event => {
    //     const curr = arr.map(v => v.b).join('');
    //     const updated = textArea.value;
    //     const diff = dmp.diff_main(curr, updated);
    //     let prevIndex = -1;
    //     let newArr = [];
    //     for (const component of diff) {
    //         const v = component[0];
    //         const str = component[1];
    //         if (v === 0) {
    //             for (let i = 0; i < str.length; i++) {
    //                 newArr.splice(newArr.length, 0, arr[i + prevIndex + 1]);
    //             }
    //             prevIndex += str.length;
    //         } else if (v === -1) {
    //             for (let i = 0; i < str.length; i++) {
    //                 changes.splice(changes.length, 0, {
    //                     a: arr[i + prevIndex + 1].a
    //                 });
    //             }
    //             prevIndex += str.length;
    //         } else {
    //             let prev = extract(prevIndex);
    //             const next = extract(prevIndex + 1);
    //             for (let i = 0; i < str.length; i++) {
    //                 const c = str.charAt(i);
    //                 let a = createPair(prev, next, c)
    //                 changes.splice(changes.length, 0, a);
    //                 newArr.splice(newArr.length, 0, a);
    //                 prev = a;
    //             }
    //         }
    //     }
    //     arr = newArr;
    // });



</script>

</html>